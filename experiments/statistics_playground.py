# Copyright (c) 2022 - for information on the respective copyright owner
# see the NOTICE file or the repository https://github.com/boschresearch/mrp-bench.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import sys
import pandas as pd
import matplotlib.pyplot as plt
# import seaborn as sb
import argparse


separator = '\n\n*******************\n*******************\n*******************\n\n'

# pass folder as arg
if __name__ == "__main__":
    # check args
    help = '''
    Output a variety of statistics or plots based on the generated csv file.
    Uncomment what you need, comment what you don't, and play with the possibilities of pandas.
    '''
    parser = argparse.ArgumentParser(description=help)
    parser.add_argument('--infile', '-f', type=str, required=True,
                        help='Relative or absolute path to the csv file generated by yaml_to_csv.py.')

    if len(sys.argv) == 1:
        parser.print_help(sys.stderr)
        sys.exit(1)
    args = parser.parse_args()

    print(f'Reading {args.infile}.')

    dfo = pd.read_csv(args.infile)
    df = dfo.copy()

    print('Algorithms detected: ')
    algos = dfo['config.pathPlanning.algorithmToCall'].unique()
    print(algos)

    print(separator)

    # check if the number of runs for each algo is the same
    value_counts = dfo.groupby('config.pathPlanning.algorithmToCall')[
        'config.pathPlanning.algorithmToCall'].value_counts()
    runsPerAlgo = 0
    if len(set(list(value_counts))) == 1:
        runsPerAlgo = list(value_counts)[0]
        print(f'Runs per algorithm: {runsPerAlgo}')
    else:
        print('WARNING! Not all algorithms have the same number of experiments!')
        print('In the current setup, this is an undefined state and this script will now terminate.')
        print(
            'If you still wish to perform calculations, make the necessary changes below.')
        print(value_counts)
        sys.exit()

    print(separator)

    # display the most common groupby's in one view:
    print('Runs by algorithm, num agents and map:\n------')
    df3 = df.groupby(['config.pathPlanning.algorithmToCall', 'config.common.random.numAgents',
                     'config.common.mapName'])['config.pathPlanning.algorithmToCall'].count()
    print(df3)

    print(separator)

    # planning success
    print('Valid schedule found by algorithm within the timeout:\n------')
    filtered = df[df['metrics.validScheduleFound'] == True]
    df2 = dict(filtered.groupby(['config.pathPlanning.algorithmToCall'])[
               'metrics.validScheduleFound'].count())
    for alg, res in df2.items():
        print(f'{alg}: {res}/{runsPerAlgo}')

    print(separator)

    # success global and local
    numGoals = dfo['config.common.random.numAgents'].unique()
    print(numGoals)

    for n in numGoals:
        print(f'Successful runs global by algorithm - {n} goals:\n------')
        df3 = df[df['metrics.goalsReached'] == n].groupby(['config.pathPlanning.algorithmToCall'])[
            'config.pathPlanning.algorithmToCall'].count()
        # df3 = df.groupby(['config.pathPlanning.algorithmToCall', 'config.pathRequests.sendPathWithBreaks'])['metrics.executionTimeoutReached'].count()
        print(df3)
        print('\n\n')

    print(separator)

   # PLOTTING

    # schedule exec time boxplooted with std dev
    # filtered  = df[df['metrics.validScheduleFound'] == True]

    # df.loc[df['metrics.totalTimeForScheduleExecution'] == 600.0, 'metrics.totalTimeForScheduleExecution'] *= 1.5

    # # dfplot = df.groupby('config.pathPlanning.algorithmToCall')

    # df2 = df[df['metrics.executionTimeoutReached'] == False]
    # plt.figure()
    # bplot = df2.boxplot(column='metrics.totalTimeForScheduleExecution', by='config.common.mapName')
    # # bplot = df.boxplot(column='metrics.totalTimeForScheduleExecution', by='config.pathPlanning.algorithmToCall')
    # bplot.set_ylabel('Execution time in seconds')
    # bplot.set_xlabel('')
    # plt.xticks(range(1, 3), ['crowdsim on', 'crowdsim off'])
    # plt.title('')
    # plt.suptitle('')
    # plt.show()

    # # # time blocked by agent
    # df = dfo.copy()

    # df = df.loc[(df['metrics.validScheduleFound'] == True)]
    # df = df.loc[(df['config.pathRequests.sendPathWithBreaks'] == True)]

    # # plt.figure()
    # mask = df.columns.str.contains('metrics.timeBlockedPerAgent.agent.*')

    # bplot = df.loc[:,mask].boxplot()
    # bplot.set_ylabel('time blocked in seconds')
    # plt.xticks(range(1, 10), ['agent '+ str(x) for x in range(1, 10)])
    # plt.title('')
    # plt.suptitle('')
    # plt.show()

    # df = dfo.copy()

    # df = df.loc[(df['metrics.validScheduleFound'] == True)]

    # df = df.loc[(df['config.pathRequests.sendPathWithBreaks'] == False)]
    # mask = df.columns.str.contains('metrics.timeBlockedPerAgent.agent.*')

    # bplot = df.loc[:,mask].boxplot()
    # bplot.set_ylabel('time blocked in seconds')
    # plt.xticks(range(1, 10), ['agent '+ str(x) for x in range(1, 10)])
    # plt.title('')
    # plt.suptitle('')
    # plt.show()
    # masked = df.loc[:,mask]
    # over400 = masked[masked > 300].count()
    # print(over400)

    # print('metrics.timeBlockedTotal by map:s\n------')
    # df4 = df.groupby(['config.common.mapName'])['metrics.timeBlockedTotal'].mean()
    # print(df4)

    # bplot = df2.boxplot(column='metrics.timeBlockedTotal', by='config.common.mapName')
    # bplot.set_ylabel('time blocked in seconds')
    # bplot.set_xlabel('')
    # plt.xticks(range(1, 3), ['crowdsim on', 'crowdsim off'])
    # plt.title('')
    # plt.suptitle('')
    # plt.show()

    # # PRINT STUFF

    # df = df.loc[(df['metrics.invalidRun'] == False)]
    # df = df.loc[(df['metrics.validScheduleFound'] == True)]

    # print('Runs by algorithm:')
    # df3 = df.groupby(['config.pathPlanning.algorithmToCall', 'config.pathRequests.sendPathWithBreaks'])['config.common.random.numAgents'].count()
    # print(df3)

    # print(separator)

    # print('validScheduleFound:\n------')
    # df3 = df.groupby(['config.pathPlanning.algorithmToCall', 'config.pathRequests.sendPathWithBreaks'])['metrics.validScheduleFound'].count()

    # print(df3)

    # print(separator)

    # print('Valid schedule found by num agents:\n------')
    # filtered = df[df['metrics.validScheduleFound'] == True]
    # df2 = filtered.groupby(['config.pathPlanning.algorithmToCall', 'config.common.random.numAgents'])['metrics.validScheduleFound'].count()
    # print(df2)

    # print(separator)

    # print('Num calc not finished:')
    # df = dfo.copy()
    # df3 = len(df.loc[(df['metrics.timeToCalculateSchedule'] > 1200.0) | (df['metrics.timeToCalculateSchedule'] == 0.0)])
    # print(df3)

    # print(separator)

    # print('Calc time by algo:\n------')
    # # actually we would need to filter out the total failures for fairness
    # filtered = df[df['metrics.validScheduleFound'] == True]
    # df2 = filtered['metrics.timeToCalculateSchedule'].describe()
    # print(df2)
    # print('++++++++++')
    # df2 = filtered.groupby(['config.common.random.numAgents', 'config.pathPlanning.algorithmToCall'])['metrics.timeToCalculateSchedule'].describe(percentiles=[0.25, 0.5, 0.75, 0.95])
    # print(df2)

    # print('Num finished by map and alg:')
    # df = dfo.copy()
    # df2 = df[df['metrics.executionTimeoutReached'] == False]
    # df3 = df2.groupby(['config.common.mapName', 'config.pathPlanning.algorithmToCall']).count()
    # print(df3)

    # print(separator)

    # print('Num finished by map and num Agents:')
    # df = dfo.copy()
    # df2 = df.loc[(df['metrics.timeToCalculateSchedule'] < 120.0) & (df['metrics.timeToCalculateSchedule'] > 0.0) & (df['config.pathPlanning.algorithmToCall'] == 'ECBS')]
    # df3 = df2.groupby(['config.common.mapName', 'config.common.random.numAgents']).count()
    # print(df3)

    # print(separator)

    # print('Cost if schedule exists for all:')
    # df = dfo.copy()
    # df['metrics.validScheduleFound'] = df['metrics.validScheduleFound'].astype(int)

    # dff = df[df.groupby(['config.common.mapName', 'config.common.random.randomSeed', 'config.common.random.numAgents'])['metrics.validScheduleFound'].transform(sum) <= 4]
    # dff = dff[(dff['config.common.mapName'] == 'airport_terminal') | (dff['metrics.cost'] < 700)]
    # num_scens_total = len(dff)
    # num_each = len(dff[dff['config.pathPlanning.algorithmToCall'] == 'AStar'])
    # mapName = 'aaairport_terminal'
    # cbs = dff[(dff['config.pathPlanning.algorithmToCall'] == 'CBS') & (dff['config.common.mapName'] != mapName)]['metrics.cost'].describe()
    # cbs_ta = dff[(dff['config.pathPlanning.algorithmToCall'] == 'CBS-TA')  & (dff['config.common.mapName'] != mapName)]['metrics.cost'].describe()
    # ecbs = dff[(dff['config.pathPlanning.algorithmToCall'] == 'ECBS') & (dff['config.common.mapName'] != mapName)]['metrics.cost'].describe()
    # ecbs_ta = dff[(dff['config.pathPlanning.algorithmToCall'] == 'ECBS-TA') & (dff['config.common.mapName'] != mapName)]['metrics.cost'].describe()

    # print('Num total: ', num_scens_total)
    # print('Num each: ', num_each)
    # print('Cost cbs: ', cbs)
    # print('Cost cbs_ta: ', cbs_ta)
    # print('Cost ecbs: ', ecbs)
    # print('Cost ecbs_ta: ', ecbs_ta)

    # print(separator)

    # print(separator)

    # print('Cost if schedule exists for all - by algo:')
    # df = dfo.copy()
    # df['metrics.validScheduleFound'] = df['metrics.validScheduleFound'].astype(int)

    # dff = df[df.groupby(['config.common.mapName', 'config.common.random.randomSeed', 'config.pathPlanning.algorithmToCall'])['metrics.validScheduleFound'].transform(sum) == 6]
    # # dff = dff[(dff['config.common.mapName'] == 'airport_terminal') | (dff['metrics.cost'] < 700)]
    # num_scens_total = len(dff)

    # num_each = len(dff[dff['config.pathPlanning.algorithmToCall'] == 'CBS'])
    # mapName = 'all'

    # results = []
    # res = dff[(dff['config.common.mapName'] != mapName)]['metrics.cost'].describe()
    # results.append((dff['config.pathPlanning.algorithmToCall'], res))

    # print('Num total: ', num_scens_total)
    # print('Num each: ', num_each)
    # for res in results:
    #     print(f'Cost {res[0]}: ', res[1])

    # print(separator)

    # print('Makespan if schedule exists for all:')
    # df = dfo.copy()
    # df['metrics.validScheduleFound'] = df['metrics.validScheduleFound'].astype(int)
    # dff = df[df.groupby(['config.common.mapName', 'config.common.random.randomSeed', 'config.common.random.numAgents'])['metrics.validScheduleFound'].transform(sum) == 2]
    # num_scens_total = len(dff)
    # num_each = len(dff[dff['config.pathPlanning.algorithmToCall'] == 'AStar'])
    # mapName = 'aaairport_terminal'
    # cbs = dff[(dff['config.pathPlanning.algorithmToCall'] == 'CBS') & (dff['config.common.mapName'] != mapName)]['metrics.makespan'].describe()
    # cbs_ta = dff[(dff['config.pathPlanning.algorithmToCall'] == 'CBS-TA')  & (dff['config.common.mapName'] != mapName)]['metrics.makespan'].describe()
    # ecbs = dff[(dff['config.pathPlanning.algorithmToCall'] == 'ECBS') & (dff['config.common.mapName'] != mapName)]['metrics.makespan'].describe()
    # ecbs_ta = dff[(dff['config.pathPlanning.algorithmToCall'] == 'ECBS-TA') & (dff['config.common.mapName'] != mapName)]['metrics.makespan'].describe()

    # print('Num total: ', num_scens_total)
    # print('Num each: ', num_each)
    # print('Makespan cbs: ', cbs)
    # print('Makespan cbs_ta: ', cbs_ta)
    # print('Makespan ecbs: ', ecbs)
    # print('Makespan ecbs_ta: ', ecbs_ta)

    # print(separator)

    # print(separator)

    # print('Cost if schedule exists for all:')
    # df['metrics.validScheduleFound'] = df['metrics.validScheduleFound'].astype(int)
    # dff = df[df.groupby(['config.common.mapName', 'config.common.random.randomSeed'])['metrics.validScheduleFound'].transform(sum) == len(algos)]
    # num_scens_total = len(dff)
    # num_each = len(dff[dff['config.pathPlanning.algorithmToCall'] == algos[0]])
    # print('Num total: ', num_scens_total)
    # print('Num each: ', num_each)

    # mapName = 'aaairport_terminal'
    # results = []
    # for algo in algos:
    #     res = dff[(dff['config.pathPlanning.algorithmToCall'] == algo) & (dff['config.common.mapName'] != mapName)]['metrics.costPreSmoothing'].mean()
    #     results.append((algo, res))

    # for res in results:
    #     print(f'Cost {res[0]}: {res[1]}')

    # print(separator)

    # print('Makespan if schedule exists for all:')
    # df['metrics.validScheduleFound'] = df['metrics.validScheduleFound'].astype(int)
    # dff = df[df.groupby(['config.common.mapName', 'config.common.random.randomSeed'])['metrics.validScheduleFound'].transform(sum) == len(algos)]
    # num_scens_total = len(dff)
    # num_each = len(dff[dff['config.pathPlanning.algorithmToCall'] == algos[0]])
    # print('Num total: ', num_scens_total)
    # print('Num each: ', num_each)

    # mapName = 'aaairport_terminal'
    # results = []
    # for algo in algos:
    #     res = dff[(dff['config.pathPlanning.algorithmToCall'] == algo) & (dff['config.common.mapName'] != mapName)]['metrics.makespanPreSmoothing'].mean()
    #     results.append((algo, res))

    # for res in results:
    #     print(f'Makespan {res[0]}: {res[1]}')

    # print(separator)

    # print('Successful runs if schedule exists for all:')
    # df['metrics.validScheduleFound'] = df['metrics.validScheduleFound'].astype(int)
    # dff = df[df.groupby(['config.common.mapName', 'config.common.random.randomSeed'])['metrics.validScheduleFound'].transform(sum) == len(algos)]
    # num_scens_total = len(dff)
    # num_each = len(dff[dff['config.pathPlanning.algorithmToCall'] == algos[0]])
    # print('Num total: ', num_scens_total)
    # print('Num each: ', num_each)

    # mapName = 'aaairport_terminal'
    # results = []
    # for algo in algos:
    #     res = dff[(dff['config.pathPlanning.algorithmToCall'] == algo) & (dff['config.common.mapName'] != mapName)]['metrics.executionTimeoutReached'].sum()
    #     results.append((algo, res))

    # for res in results:
    #     print(f'# successful {res[0]}: {num_each - res[1]}')

    # print(separator)

    # print('Agent at goal if sched. exists for all:')
    # df['metrics.validScheduleFound'] = df['metrics.validScheduleFound'].astype(int)
    # dff = df[df.groupby(['config.common.mapName', 'config.common.random.randomSeed'])['metrics.validScheduleFound'].transform(sum) == len(algos)]
    # num_scens_total = len(dff)
    # num_each = len(dff[dff['config.pathPlanning.algorithmToCall'] == algos[0]])
    # print('Num total: ', num_scens_total)
    # print('Num each: ', num_each)

    # mapName = 'aaairport_terminal'
    # results = []
    # for algo in algos:
    #     res = dff[(dff['config.pathPlanning.algorithmToCall'] == algo) & (dff['config.common.mapName'] != mapName)]['metrics.goalsReached'].mean()
    #     results.append((algo, res))

    # for res in results:
    #     print(f'mean agents at goal {res[0]}: {res[1]}')

    # print(separator)

    # print(separator)
    # print('Num successful airport 5, 9:')
    # ecbs = df[(df['config.pathPlanning.algorithmToCall'] == 'ECBS') & (dff['config.common.mapName'] == 'airport_terminal') & (dff['config.common.random.numAgents'] == 5)  & (df['metrics.timeToCalculateSchedule'] < 1200.0) & (df['metrics.timeToCalculateSchedule'] > 0.0)]['metrics.timeToCalculateSchedule'].mean()
    # print(ecbs)

    # ecbs = df[(df['config.pathPlanning.algorithmToCall'] == 'ECBS') & (dff['config.common.mapName'] == 'airport_terminal') & (dff['config.common.random.numAgents'] == 9)  & (df['metrics.timeToCalculateSchedule'] < 1200.0) & (df['metrics.timeToCalculateSchedule'] > 0.0)]['metrics.timeToCalculateSchedule'].mean()
    # print(ecbs)

    # print(separator)

    # print('Schedule exec time by num agents:\n------')
    # filtered = df[df['metrics.allGoalReached'] == True]
    # df2 = filtered.groupby(['config.pathPlanning.algorithmToCall'])['metrics.totalTimeForScheduleExecution'].describe()
    # print(df2)
    # print('++++++++++')
    # df2 = filtered.groupby(['config.pathPlanning.algorithmToCall', 'config.common.random.numAgents'])['metrics.totalTimeForScheduleExecution'].describe()
    # print(df2)

    # print(separator)

    # print('Min dist between two agents:\n------')
    # filtered = df[(df['metrics.validScheduleFound'] == True) & (df['config.common.random.numAgents'] > 1)]
    # df2 = filtered.groupby(['config.pathPlanning.algorithmToCall'])['metrics.minDistanceBetweenTwoAgents'].describe()
    # print(df2)
    # print('++++++++++')
    # df2 = filtered.groupby(['config.pathPlanning.algorithmToCall', 'config.common.random.numAgents'])['metrics.minDistanceBetweenTwoAgents'].describe()
    # print(df2)

    # print(separator)

    # print('Makespan / total time for exec\nOnly when all goals were reached\nIf this is smaller, this means the result was closer to what is expected\n------')
    # df['quotient'] = df['metrics.makespan'] / df['metrics.totalTimeForScheduleExecution']
    # filtered = df[(df['metrics.allGoalReached'] == True)]
    # df2 = filtered.groupby(['config.pathPlanning.algorithmToCall'])['quotient'].describe()
    # print(df2)

   # timed analysis

    # print(separator)
    # df = dfo.copy()
    # # df = df.loc[(df['metrics.invalidRun'] == False)]

    # print('Instances where all three were successful:\n------')

    # df = df.loc[(df['metrics.validScheduleFound'] == True)]
    # df['metrics.invalidRun'] = df['metrics.invalidRun'].astype(int)
    # dff = df[df.groupby(['config.common.random.randomSeed', 'config.pathRequests.sendPathWithBreaks'])['metrics.invalidRun'].transform(sum) == 0]

    # print(dff[['config.pathPlanning.algorithmToCall', 'config.common.random.randomSeed', 'config.pathRequests.sendPathWithBreaks', 'metrics.allGoalReached']].sort_values(by=['config.common.random.randomSeed', 'config.pathRequests.sendPathWithBreaks']))

    # print('Success rate by alg for scenarios where all 3 were successful:\n------')
    # num_scens_total = len(dff)
    # num_each = len(dff[dff['config.pathPlanning.algorithmToCall'] == 'ECBS']) / 2
    # # success_astar = len(dff[(dff['config.pathRequests.sendPathWithBreaks'] == False) & (dff['config.pathPlanning.algorithmToCall'] == 'AStar') & (dff['metrics.executionTimeoutReached'] == False) & (dff['metrics.validScheduleFound'] == True)])
    # # success_astar_timed = len(dff[(dff['config.pathRequests.sendPathWithBreaks'] == True) & (dff['config.pathPlanning.algorithmToCall'] == 'AStar') & (dff['metrics.executionTimeoutReached'] == False) & (dff['metrics.validScheduleFound'] == True)])
    # # success_cbs = len(dff[(dff['config.pathRequests.sendPathWithBreaks'] == False) & (dff['config.pathPlanning.algorithmToCall'] == 'CBS')  & (dff['metrics.executionTimeoutReached'] == False) & (dff['metrics.validScheduleFound'] == True)])
    # # success_cbs_timed = len(dff[(dff['config.pathRequests.sendPathWithBreaks'] == True) & (dff['config.pathPlanning.algorithmToCall'] == 'CBS')  & (dff['metrics.executionTimeoutReached'] == False) & (dff['metrics.validScheduleFound'] == True)])
    # success_ecbs = len(dff[(dff['config.pathRequests.sendPathWithBreaks'] == False) & (dff['config.pathPlanning.algorithmToCall'] == 'ECBS')  & (dff['metrics.executionTimeoutReached'] == False) & (dff['metrics.validScheduleFound'] == True)])
    # success_ecbs_timed = len(dff[(dff['config.pathRequests.sendPathWithBreaks'] == True) & (dff['config.pathPlanning.algorithmToCall'] == 'ECBS')  & (dff['metrics.executionTimeoutReached'] == False) & (dff['metrics.validScheduleFound'] == True)])

    # mean_exec_ecbs = dff[(dff['config.pathRequests.sendPathWithBreaks'] == False) & (dff['config.pathPlanning.algorithmToCall'] == 'ECBS')  & (dff['metrics.executionTimeoutReached'] == False) & (dff['metrics.validScheduleFound'] == True)]['metrics.maxRobotsSeen'].mean()
    # mean_exec_ecbs_timd = dff[(dff['config.pathRequests.sendPathWithBreaks'] == True) & (dff['config.pathPlanning.algorithmToCall'] == 'ECBS')  & (dff['metrics.executionTimeoutReached'] == False) & (dff['metrics.validScheduleFound'] == True)]['metrics.maxRobotsSeen'].mean()

    # print('Num total: ', num_scens_total)
    # print('Num each: ', num_each)
    # # print('success_astar', success_astar)
    # # print('rel success rate astar ut: ', success_astar / num_each)
    # # print('rel success rate astar timed: ', success_astar_timed / num_each)
    # # print('rel success rate cbs ut: ', success_cbs / num_each)
    # # print('rel success rate cbs timed: ', success_cbs_timed / num_each)
    # print('rel success rate ecbs ut: ', success_ecbs / num_each)
    # print('rel success rate ecbs timed: ', success_ecbs_timed / num_each)

    # print('mean time ecbs: ', mean_exec_ecbs)
    # print('mean time ecbs timed: ', mean_exec_ecbs_timd)

    # print(separator)
    # print(df[['config.pathRequests.sendPathWithBreaks', 'metrics.executionTimeoutReached', 'metrics.goalsReached']])

    # print(separator)
    # df = dfo.copy()
    # print('Success rate by alg for scenarios where all 3 were successful:\n------')
    # df['metrics.validScheduleFound'] = df['metrics.validScheduleFound'].astype(int)
    # dff = df[df.groupby(['config.common.mapName', 'config.common.random.randomSeed', 'config.common.random.numAgents'])['metrics.validScheduleFound'].transform(sum) == 3]
    # num_scens_total = len(dff)
    # # num_each = len(dff[dff['config.pathPlanning.algorithmToCall'] == 'AStar'])
    # success_astar = len(dff[(dff['config.pathPlanning.algorithmToCall'] == 'AStar') & (dff['metrics.executionTimeoutReached'] == False) & (dff['metrics.validScheduleFound'] == True)])
    # fail_astar = len(dff[(dff['config.pathPlanning.algorithmToCall'] == 'AStar') & ((dff['metrics.executionTimeoutReached'] == True) | (dff['metrics.validScheduleFound'] == False))])
    # success_cbs = len(dff[(dff['config.pathPlanning.algorithmToCall'] == 'CBS')  & (dff['metrics.executionTimeoutReached'] == False) & (dff['metrics.validScheduleFound'] == True)])
    # success_ecbs = len(dff[(dff['config.pathPlanning.algorithmToCall'] == 'ECBS')  & (dff['metrics.executionTimeoutReached'] == False) & (dff['metrics.validScheduleFound'] == True)])

    # print('Num total: ', num_scens_total)
    # # print('Num each: ', num_each)
    # print('success_astar', success_astar)
    # print('rel success rate astar: ', success_astar / len(dff[dff['config.pathPlanning.algorithmToCall'] == 'AStar']))
    # print('rel fail rate astar: ', fail_astar / len(dff[dff['config.pathPlanning.algorithmToCall'] == 'AStar']))
    # print('rel success rate cbs: ', success_cbs / len(dff[dff['config.pathPlanning.algorithmToCall'] == 'CBS']))
    # print('rel success rate ecbs: ', success_ecbs / len(dff[dff['config.pathPlanning.algorithmToCall'] == 'ECBS']))

    # print(separator)
    # dff = dfo.copy()

    # dff = dff[dff['config.common.mapName'] == 'airport_terminal']
    # # dff = dff[dff['config.common.random.numAgents'] == 20]
    # print('Success rate schedule:\n------')
    # num_scens_total = len(dff)
    # num_each = len(dff[dff['config.pathPlanning.algorithmToCall'] == 'ECBS'])
    # # success_astar = len(dff[(dff['config.pathPlanning.algorithmToCall'] == 'AStar') & (dff['metrics.executionTimeoutReached'] == False) & (dff['metrics.validScheduleFound'] == True)])
    # success_cbs = len(dff[(dff['config.pathPlanning.algorithmToCall'] == 'CBS')  & (dff['metrics.validScheduleFound'] == True)])
    # success_cbs_ta = len(dff[(dff['config.pathPlanning.algorithmToCall'] == 'CBS-TA') & (dff['metrics.validScheduleFound'] == True)])
    # success_ecbs = len(dff[(dff['config.pathPlanning.algorithmToCall'] == 'ECBS') & (dff['metrics.validScheduleFound'] == True)])
    # success_ecbs_ta = len(dff[(dff['config.pathPlanning.algorithmToCall'] == 'ECBS-TA') & (dff['metrics.validScheduleFound'] == True)])

    # print('Num total: ', num_scens_total)
    # print('Num each: ', num_each)
    # # print('success_astar', success_astar)
    # # print('abs success rate astar: ', success_astar / len(dff[dff['config.pathPlanning.algorithmToCall'] == 'AStar']))
    # print('abs success rate cbs: ', success_cbs / len(dff[dff['config.pathPlanning.algorithmToCall'] == 'CBS']))
    # print('abs success rate cbs-ta: ', success_cbs_ta / len(dff[dff['config.pathPlanning.algorithmToCall'] == 'CBS-TA']))
    # print('abs success rate ecbs: ', success_ecbs / len(dff[dff['config.pathPlanning.algorithmToCall'] == 'ECBS']))
    # print('abs success rate ecbs-ta: ', success_ecbs_ta / len(dff[dff['config.pathPlanning.algorithmToCall'] == 'ECBS-TA']))

    # print(separator)
    # print('Failures Astar when others have no schedule:\n------')
    # df = dfo.copy()
    # df['metrics.validScheduleFound'] = df['metrics.validScheduleFound'].astype(int)
    # dff = df[df.groupby(['config.common.mapName', 'config.common.random.randomSeed', 'config.common.random.numAgents'])['metrics.validScheduleFound'].transform(sum) < 3]
    # num_scens_total = len(dff)
    # num_each = len(dff[dff['config.pathPlanning.algorithmToCall'] == 'AStar'])
    # fail_astar = len(dff[(dff['config.pathPlanning.algorithmToCall'] == 'AStar') & (dff['metrics.executionTimeoutReached'] == True)])

    # print('Num total: ', num_scens_total)
    # print('Num each: ', num_each)
    # print('num fail astar: ', fail_astar)
    # print('rate fail astar: ', fail_astar/num_each)

    # print(separator)
    # df = dfo.copy()
    # print('Mean number of goals reached where all 3 were successful, N goals max:\n------')
    # df['metrics.validScheduleFound'] = df['metrics.validScheduleFound'].astype(int)
    # dff = df[df.groupby(['config.common.mapName', 'config.common.random.randomSeed', 'config.common.random.numAgents'])['metrics.validScheduleFound'].transform(sum) <= 3]
    # num_scens_total = len(dff)
    # num_each = len(dff[dff['config.pathPlanning.algorithmToCall'] == 'AStar'])
    # goals = 5
    # astar = dff[(dff['config.pathPlanning.algorithmToCall'] == 'AStar') & (dff['config.common.random.numAgents'] == goals)]['metrics.goalsReached'].mean()
    # cbs = dff[(dff['config.pathPlanning.algorithmToCall'] == 'CBS')  & (dff['config.common.random.numAgents'] == goals)]['metrics.goalsReached'].sum()
    # ecbs = dff[(dff['config.pathPlanning.algorithmToCall'] == 'ECBS') & (dff['config.common.random.numAgents'] == goals)]['metrics.goalsReached'].sum()

    # cbs2 = df[(df['config.pathPlanning.algorithmToCall'] == 'CBS')  & (df['config.common.random.numAgents'] == goals)]['metrics.goalsReached']

    # print('Num total: ', num_scens_total)
    # print('Num each: ', num_each)
    # print('Goal astar: ', astar)
    # print('Goal cbs: ', cbs)
    # print('Goal ecbs: ', ecbs)

    # time blocked by scenario
    # print(separator)

    # df = dfo.copy()
    # df['metrics.validScheduleFound'] = df['metrics.validScheduleFound'].astype(int)
    # dff = df[df.groupby(['config.common.mapName', 'config.common.random.randomSeed', 'config.common.random.numAgents'])['metrics.validScheduleFound'].transform(sum) == 3]
    # dff = dff[dff['metrics.executionTimeoutReached'] == False]
    # fig, axes = plt.subplots()

    # # bplot = dff.groupby('config.pathPlanning.algorithmToCall').boxplot(column='metrics.timeBlockedTotal', subplots=False)
    # # bplot.set_ylabel('time blocked in seconds')
    # # plt.xticks(range(1, 4), ['agent '+ str(x) for x in range(1, 10)])

    # dfv =  [
    #         dff[(dff['config.pathPlanning.algorithmToCall'] == 'AStar')]['metrics.timeBlockedTotal'].values,
    #         dff[(dff['config.pathPlanning.algorithmToCall'] == 'CBS')]['metrics.timeBlockedTotal'].values,
    #         dff[(dff['config.pathPlanning.algorithmToCall'] == 'ECBS')]['metrics.timeBlockedTotal'].values
    #     ]

    # axes.violinplot(dataset = dfv, showmeans=True, showextrema=True)

    # axes.yaxis.grid(True)
    # axes.set_ylabel('Time spent blocked (s)')
    # plt.xticks(range(1, 4), ['AStar', 'CBS', 'ECBS'])
    # plt.title('')
    # plt.suptitle('')
    # plt.show()

    # grouped  = df.groupby(['config.pathPlanning.algorithmToCall', 'metrics.validScheduleFound', 'config.common.random.randomSeed'])
    # # filtered = df[(df['config.pathPlanning.algorithmToCall']) == 'ECBS']
    # # df2 = filtered.groupby(['config.pathPlanning.algorithmToCall', 'config.common.random.numAgents'])['metrics.validScheduleFound'].count()
    # print(grouped)
